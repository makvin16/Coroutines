package coroutines

/**
 * Фоновая работа. Концептуально работа — это нечто, что можно отменить, жизненный цикл которой завершается ее завершением.
 *
 * Джобы могут быть организованы в иерархии родитель-потомок,
 * где отмена родительского объекта приводит к немедленной рекурсивной отмене всех его дочерних элементов.
 * Сбой дочернего объекта с исключением, отличным от CancellationException, немедленно отменяет его родительский элемент и,
 * следовательно, все его остальные дочерние элементы. Это поведение можно настроить с помощью SupervisorJob.
 *
 * Самые простые экземпляры интерфейса Job создаются следующим образом:
 * * Coroutine Job создается с помощью запуска корутин билдера. Он запускает указанный блок кода и завершается после завершения этого блока.
 * * CompletableJob создается с помощью фабричной функции Job(). Завершается вызовом CompletableJob.complete.
 *
 * Концептуально выполнение джобы не приводит к получению результата.
 * Джобы запускаются исключительно из-за их побочных эффектов. См. [Deferred] интерфейс для задания, которое дает результат.
 *
 * Job states
 * | **State**                        | [isActive] | [isCompleted] | [isCancelled] |
 * | -------------------------------- | ---------- | ------------- | ------------- |
 * | _New_ (optional initial state)   | `false`    | `false`       | `false`       |
 * | _Active_ (default initial state) | `true`     | `false`       | `false`       |
 * | _Completing_ (transient state)   | `true`     | `false`       | `false`       |
 * | _Cancelling_ (transient state)   | `false`    | `false`       | `true`        |
 * | _Cancelled_ (final state)        | `false`    | `true`        | `true`        |
 * | _Completed_ (final state)        | `false`    | `true`        | `false`       |
 *
 * Обычно джоба создается в активном состоянии (создано и запущено).
 * Однако разработчики корутин, которые предоставляют необязательный параметр запуска,
 * создают корутину в новом состоянии, когда для этого параметра установлено значение [CoroutineStart.LAZY].
 * Такую джобу можно сделать активным, вызвав [start] или [join].
 *
 * Джоба активна, пока работает корутина, или пока [CompletableJob] не завершится, или пока она не завершится сбоем или не будет отменена.
 *
 * Сбой активной джобы с исключением приводит к ее отмене. Джобу можно отменить в любой момент с помощью функции [cancel],
 * которая заставляет ее немедленно перейти в состояние _сancelling_.
 * Джоба становиться _сancelled_, когда она завершает выполнение своей работы и все ее дочерние элементы завершаются.
 *
 * Завершение тела активной корутины или вызов [CompletableJob.complete] переводит джобу в состояние _сompleting_.
 * В состоянии _сompleting_ она ожидает завершения всех своих дочерних элементов, прежде чем перейти в состояние _сompleted_.
 * Обратите внимание, что состояние _сompleting_ является чисто внутренним для джобы.
 * Для стороннего наблюдателя завершающееся джобы все еще активны, в то время как внутри она ожидает своих дочерних элементов.
 *
 *                                       wait children
 * +-----+ start  +--------+ complete   +-------------+  finish  +-----------+
 * | New | -----> | Active | ---------> | Completing  | -------> | Completed |
 * +-----+        +--------+            +-------------+          +-----------+
 *                  |  cancel / fail       |
 *                  |     +----------------+
 *                  |     |
 *                  V     V
 *              +------------+                           finish  +-----------+
 *              | Cancelling | --------------------------------> | Cancelled |
 *              +------------+                                   +-----------+
 *
 * Причины отмены
 *
 * Говорят, что джоба корутины завершается исключительно, когда его тело генерирует исключение;
 * CompletableJob завершается в исключительном порядке путем вызова CompletableJob.completeExceptionally.
 * Исключительно завершенная джоба отменяется, и соответствующее исключение становится причиной отмены задания.
 *
 * Обычная отмена джобы отличается от ее сбоя типом исключения, вызвавшего ее отмену.
 * Корутина, выдавшая CancellationException, считается отмененной в обычном режиме.
 * Если причиной отмены является исключение другого типа, джоба считается невыполненой.
 * Если джоба не выполнена, ее родительский элемент отменяется, за исключением того же типа,
 * что обеспечивает прозрачность делегирования частей джобы ее дочерним элементам.
 *
 * Обратите внимание, что функция отмены джобы принимает только CancellationException в качестве причины отмены,
 * поэтому вызов отмены всегда приводит к нормальной отмене задания, что не приводит к отмене ее родительского объекта.
 * Таким образом, родитель может отменить своих собственных дочерних элементов (также рекурсивно отменяя всех своих дочерних элементов),
 * не отменяя себя.
 */
interface Job : CoroutineContext.Element {

    companion object Key : CoroutineContext.Key<Job>

    // ------------ state query ------------

    /**
     * Возвращает true, когда джоба активна — оно уже запущена, не завершена и не отменена.
     * Джоба, ожидающая завершения своих дочерних элементов, по-прежнему считается активной,
     * если оно не было отменена или не выполнена с ошибкой.
     */
    val isActive: Boolean

    /**
     * Возвращает true, когда джоба завершена по какой-либо причине.
     * Джоба, которая была отменена или завершилась неудачей и завершила свое выполнение, также считается завершенном.
     * Джоба становится завершенной только после того, как завершатся все ее дочерние элементы.
     */
    val isCompleted: Boolean

    /**
     * Возвращает true, если это джоба была отменена по какой-либо причине, либо из-за явного вызова отмены,
     * либо из-за сбоя, либо из-за того, что ее дочерний или родительский элемент был отменен.
     * В общем случае это не означает, что джоба уже завершена, поскольку она все еще может завершать то, что делала,
     * и ожидать завершения своих дочерних элементов.
     */
    val isCancelled: Boolean

    // ------------ state update ------------

    /**
     * Запускает корутину, связанную с этой джобой (если таковая имеется), если она еще не запущена.
     * Результат будет истинным, если этот вызов действительно запустил сопрограмму, или ложным, если он уже был запущен или завершен.
     */
    fun start(): Boolean
}

@Suppress("FunctionName")
fun Job(parent: Job? = null): CompletableJob {
    return JobImpl(parent)
}

@Deprecated("This is internal API and may be removed in the future releases")
interface ChildJob : Job

@Deprecated("This is internal API and may be removed in the future releases")
interface ParentJob : Job