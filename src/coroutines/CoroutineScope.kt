package coroutines

/**
 * Определяет область действия для новых корутин. Каждый **корутин билдер** (например, [launch], [async] и т. д.)
 * является расширением [CoroutineScope] и наследует его [coroutineContext][CoroutineScope.coroutineContext]
 * для автоматического распространения всех его элементов и отмены.
 *
 * Лучшими способами получения автономного экземпляра (standalone instance) области видимости являются
 * фабричные функции [CoroutineScope()] и [MainScope()], при этом необходимо позаботиться об отмене этих корутин скоупа,
 * когда они больше не нужны (объяснения и примеры см. в разделе о пользовательском использовании ниже).
 *
 * Дополнительные элементы контекста можно добавить к скоупу с помощью оператора плюс.
 *
 * ### Соглашение о *структурированном параллелизме(structured concurrency)*
 *
 * Ручная реализация этого интерфейса не рекомендуется, вместо этого следует использовать делегирование.
 * По договоренности, контекст скоупа [CoroutineScope.coroutineContext] должен содержать экземпляр [job][Job]
 * для обеспечения соблюдения дисциплины *структурированного параллелизма(structured concurrency)* с распространением отмены.
 *
 * Каждый корутин билдер (например, [launch], [async] и другие)
 * и каждая *функция области видимости(scoping function)* (например, [coroutineScope] и [withContext]) предоставляют
 * свой собственный скоуп со своим собственным экземпляром [Job] во внутреннем блоке кода, который он выполняет.
 * По договоренности, все они ждут завершения всех корутин внутри своего блока, прежде чем завершиться сами,
 * тем самым обеспечивая *структурированный параллелизм(structured concurrency)*.
 *
 * ### Android применение
 *
 * В Android имеется собственная поддержка корутин скоупов во всех объектах жизненного цикла.
 * See [the corresponding documentation](https://developer.android.com/topic/libraries/architecture/coroutines#lifecyclescope).
 *
 * ### Кастомное применение
 *
 * CoroutineScope следует объявлять как свойство объектов с четко определенным жизненным циклом,
 * которые отвечают за запуск дочерних корутин. Соответствующий экземпляр CoroutineScope должен быть создан с помощью
 * CoroutineScope() или MainScope():
 *
 * * CoroutineScope() использует предоставленный ему контекст в качестве параметра для своих корутин и добавляет джобу,
 * если она не указано как часть контекста.
 * * MainScope() использует [Dispatchers.Main] для своих корутин и имеет [SupervisorJob].
 *
 * Ключевой частью кастомного использования CoroutineScope является его отмена в конце жизненного цикла.
 * Функция расширения [CoroutineScope.cancel] должна использоваться, когда объект, запускавший корутину, больше не нужен.
 * Он отменяет все корутины, которые все еще могут выполняться от его имени.
 */
interface CoroutineScope {
    /**
     * Контекст скоупа. Контекст инкапсулируется скоупом и используется для реализации корутин билдеров,
     * которые являются расширениями от скоупов. Доступ к этому свойству в общем коде не рекомендуется для каких-либо целей,
     * за исключением доступа к экземпляру [Job] для расширенного использования.
     * По договоренности должен содержать экземпляр [Job] для обеспечения *структурированного параллелизма(structured concurrency)*.
     */
    val coroutineContext: CoroutineContext
}

object GlobalScope : CoroutineScope {
    override val coroutineContext: CoroutineContext
        get() = EmptyCoroutineContext
}

fun CoroutineScope(context: CoroutineContext): CoroutineScope {
    val job = context[Job]
    println(job)
    val coroutineContext = if (context[Job] != null) context else context + Job()
    return ContextScope(coroutineContext)
}